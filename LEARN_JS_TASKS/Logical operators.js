//1. Применение унарного минуса к численному типу
let a = 11;
a = -a;
console.log(a); //a = -11 применение унарного минуса

/*1.1 Применение унарного минуса к булевому значению возвращает число.
Унарный плюс тоже самое - работа по принципу метода Number()
 */

let bool = true;
bool = -true;
console.log(bool); //-1

//Но бинарный минус всегда приводит строки к числам
let num = 1;
let cif = '2';
console.log(num - cif); //-1

//2. Конкатенация строк бинарным плюсом
let b = 'papa';
let c = 'roach';
console.log(b + c); //paparoach

/*Тоже самое для чисел в виде строк - если хотя бы один аргумент - строка,
 оба аргумента будут приведены к строке
  */

console.log(num + cif); // 1+'2' = '12'

//2.1 Бинарный плюс при применении к строкам, в которых содержатся числа парсит их и использует как математический плюс
let stringNumber = '123';
console.log(+stringNumber + +cif); //123 + 2 = 125

//3. Оператор остаток от деления и приоритезация операций скобками () и применением унарного плюса
console.log(+'123'% (+'2' + 3)); // Ответ 3. Скобки являются наиболее приоритетным оператором, затем унарный плюс и только потом остаток от деления

//4. Оператор присваивания. Инкременты и декременты в постфиксной и префиксной форме
/* Префиксная форма инкремента и декремента отличается от постфиксной выводом значения переменной:
В постфиксной форме значение переменной изменится на указанную еденицу, но выведет старое значение,
а в префиксной форме - выведет новое значение сразу же после примененения. Инкременты и декременты применимы
ТОЛЬКО к переменным.
 */

let i = 0;
i++; //0
console.log(i); //1

//Равнозначно записи
i = i + 1;

//а так же (как и со знаком * , / , %)
i += 1;

//5. Логические операторы сравнения возвращают булево значение (true / false)
console.log(num > cif); // 1 > '2' = false, т.к. строка приводится к числу
console.log(b > c); //false - строки сравниваются по лексикографическому значению Unicode

//5.1 Строгое и нестрогое равенство отличается тем, что при строгом равенстве не используется приведение автоматическое приведение типов:
let x = 1;
let y = '1';
console.log(y == x); //true - '1' приводится к числу
console.log(y === x); // false - не происходит приведения типа
// Аналогично с отрицанием
console.log(y != x); //false
console.log(y !== x); //true

//Null & undefined
console.log(null == undefined); //true - null & undefined - специальные значения, которые равны себе и только себе
console.log(null === undefined); //false - но в строгом сравнении - нет, т.к. это два отдельных типа данных
